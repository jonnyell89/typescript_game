# typescript_game

# Minesweeper

Minesweeper is a logic puzzle game. The game features a grid of cells that contain hidden values. The hidden values can either be empty, a number or a mine. The aim of the game is to plant a flag on all cells that contain a mine. This is done by revealing the hidden value of all other cells. If the user selects an empty cell, all connected empty cells and their adjacent numbered cells are revealed. If the user selects a cell containing a number, the number refers to the number of mines immediately adjacent to that cell. If the user selects a cell containing a mine, the game is over, and the user has lost. The user must use the cells that contain numbers to determine which cells contain mines and which cells can be safely selected. The game ends when all cells that do not contain a mine have been revealed, or when the user accidentally selects a mine, and loses the game.

# HTML

- [x] GUI

  - [x] Container

    - [x] Top container

      - [x] Display containing the number of remaining mines.
      - [x] Display containing the time.
      - [x] Reset button

    - [x] Bottom container

      - [x] Grid (9 x 9)

        - [x] Buttons

          - [x] Empty cells
          - [x] Cells containing a reference to the number of adjacent mines.
          - [x] 10 cells containing mines.

# SCSS

- [x] Responsive Design

  - [x] Mobile-first design
  - [x] Rescale for different screen dimensions.

- [x] GUI

  - [x] All cells start hidden from the user.

  - [x] Cell types:

    - [x] Empty cells contain no value, but are connected to all adjacent empty cells.

    - [x] Cells containing reference numbers:

      - [x] 1: Blue
      - [x] 2: Green
      - [x] 3: Yellow
      - [x] 4: Purple
      - [x] 5: Light Red
      - [x] 6: Dark Red
      - [x] 7: Orange
      - [x] 8: Black

    - [x] Cells containing mines:

      - [x] Mine: Bomb emoji

  - [x] Button hover feedback

  - [x] Grid interaction disables when the game is won or lost.

# TypeScript

- [x] Functionality

  - [x] Top container

    - [x] Display containing the number of remaining mines.

      - [x] Counts down from 10 to zero with each flag planted.

    - [x] Display containing the time.

      - [x] Counts up from zero.

    - [x] Reset button resets:

      - [x] Mine display
      - [x] Time display
      - [x] Grid

        - [x] Mine configuration
        - [x] Reference number configuration
        - [x] All revealed cells back to initial state.

  - [x] Bottom container

    - [x] Grid

      - [x] Start timer on first grid interaction.

      - [x] Left click on a cell to reveal its value.

        - [x] If cell is empty, reveals all connected empty cells.

        - [x] If cell contains a reference number, no other cells are revealed.

        - [x] If cell contains a mine, all remaining mines are revealed.

      - [x] Right click on a cell to plant a flag.

      - [x] Detect when all cells that do not contain a mine have been revealed.

# Pseudocode

Global variables:

GRID_WIDTH = 9 GRID_HEIGHT = 9 MINE_COUNT = 10

Requirements:

Game Logic:

The game requires a grid of cells, represented as a two-dimensional array.

Each cell of the grid is to be a Cell type object, containing all necessary information:

    cellElement: button;
    xCoord: number;
    yCoord: number;
    isHidden: boolean;
    hasFlag: boolean;
    hasMine: boolean;
    adjacentMines: number;

A function that generates Cell type objects.

    Input values are x and y coordinates, generated by a nested for loop.

    Properties of type boolean are set to default values.

    Returns a Cell type object.

    This function is called as a helper function to the generateGrid function.

A function to generate a two-dimensional list of Cell type objects, representing the minesweeper grid.

Input values are grid dimensions, set as global variables.

Nested for loop:

        Generates a two-dimensional array, representing the minesweeper grid.

        Generates x and y coordinates.

        Calls the generateCell helper function at every index position in the two-dimensional array.

Returns a two-dimensional array of Cell type objects, representing the minesweeper grid.

A function that uses pseudo random numbers to generate grid coordinates for mine placements.

Input values are a two-dimensional array of Cell type objects, and the number of mines, set as a global variable.

Initialise an assignedMine variable to track successful mine placements.

While assignedMines less than numberOfMines:

      Generate random cell coordinates:

        If cell already contains a mine, continue.

        Else, mine placement at that cell.

        Increment assignedMines.

Returns an array of successful mine placement grid coordinates.

A function that assigns each cell a value by counting the number of adjacent mine placements for every cell. This means the surrounding eight cells for every central cell, the surrounding five cells for every edge cell, and the surrounding three cells for every corner cell.

There are two options for this function:

    Iterate over the grid and count the number of adjacent mine placements for every cell. This involves counting all adjacent mine placements and incrementing the adjacentMines property for each individual Cell type object, before moving on to the next cell of the grid.

    Iterate over an array of mine placement coordinates and increment the adjacentMines property for each adjacent Cell type object directly. This involves incrementing the adjacentMines property of each adjacent Cell type object by 1, before moving on to the next mine placement in the array.

I favour the more direct appraoch of iterating over an array of mine placement coordinates:

    Input values are a two-dimensional array of Cell type objects, representing the minesweeper grid, and an array of mine placement grid coordinates.

    For loop:

        Iterate over the mineCoordinates array.

        Access x and y coordinates for each mine placement and pass them into a helper function.

A series of helper functions that apply a single increment to the adjacentMines property for each Cell type object, immediately adjacent to the mine placement coordinate.

These functions require several conditional statements to account for mine placements that occur at the edge of the grid, and for mine placements that occur in the corner of the grid.

Central placements logic, for central mine placements:

      If the x coordinate is greater than 0 and less than 8,
        and if the y coordinate is greater than 0 and less than 8.

      For loop:

        Iterate over a 3x3 subgrid where the current mine placement cell is the central cell of the subgrid.

        If hasMine property is true, continue.

          This step is the logic that skips the central cell of the subgrid, and any other adjacent mine placements.

        Else, increment adjacentMines property.

This helper function and the series of associated helper functions have now been generalised into a single function. The key piece of logic that enabled this refactor was a general boundary check that prevented out of bounds errors when incrementing adjacentMines properties for edge and corner cases.

The repeated logic for all nine edge and corner cases now exists in the archive.ts file.

A recursive algorithm that reveals Cell type objects when the user selects a cell on the minesweeper grid. The function must reveal all connected Cell type objects with an adjacentMines property of zero. This action also includes revealing all adjacent Cell type objects with an adjacentMines property of greater than zero. The function must also reveal single Cell type objects that have an adjacentMines property of greater than zero. And finally, the function must also trigger a game over condition when the user selects a Cell type object that contains a mine.

The logic for the recursive algorithm has been adapted and expanded from the following source: https://stackoverflow.com/questions/44554985/i-cant-figure-out-the-minesweeper-recursive-algorithm
